package ntpserver

import (
	"context"
	"fmt"
	"strings"

	"github.com/citrix/adc-nitro-go/resource/config/ntp"

	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/citrix/terraform-provider-citrixadc/citrixadc_framework/utils"
)

// NtpserverResourceModel describes the resource data model.
type NtpserverResourceModel struct {
	Id                 types.String `tfsdk:"id"`
	Autokey            types.Bool   `tfsdk:"autokey"`
	Key                types.Int64  `tfsdk:"key"`
	Maxpoll            types.Int64  `tfsdk:"maxpoll"`
	Minpoll            types.Int64  `tfsdk:"minpoll"`
	Preferredntpserver types.String `tfsdk:"preferredntpserver"`
	Serverip           types.String `tfsdk:"serverip"`
	Servername         types.String `tfsdk:"servername"`
}

func (r *NtpserverResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version: 1,
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed:    true,
				Description: "The ID of the ntpserver resource.",
			},
			"autokey": schema.BoolAttribute{
				Optional:    true,
				Computed:    true,
				Description: "Use the Autokey protocol for key management for this server, with the cryptographic values (for example, symmetric key, host and public certificate files, and sign key) generated by the ntp-keygen utility. To require authentication for communication with the server, you must set either the value of this parameter or the key parameter.",
			},
			"key": schema.Int64Attribute{
				Optional:    true,
				Computed:    true,
				Description: "Key to use for encrypting authentication fields. All packets sent to and received from the server must include authentication fields encrypted by using this key. To require authentication for communication with the server, you must set either the value of this parameter or the autokey parameter.",
			},
			"maxpoll": schema.Int64Attribute{
				Optional:    true,
				Computed:    true,
				Description: "Maximum time after which the NTP server must poll the NTP messages. In seconds, expressed as a power of 2.",
			},
			"minpoll": schema.Int64Attribute{
				Optional:    true,
				Computed:    true,
				Description: "Minimum time after which the NTP server must poll the NTP messages. In seconds, expressed as a power of 2.",
			},
			"preferredntpserver": schema.StringAttribute{
				Optional:    true,
				Computed:    true,
				Description: "Preferred NTP server. The Citrix ADC chooses this NTP server for time synchronization among a set of correctly operating hosts.",
			},
			"serverip": schema.StringAttribute{
				Optional:    true,
				Computed:    true,
				Description: "IP address of the NTP server.",
			},
			"servername": schema.StringAttribute{
				Optional:    true,
				Computed:    true,
				Description: "Fully qualified domain name of the NTP server.",
			},
		},
	}
}

func ntpserverGetThePayloadFromtheConfig(ctx context.Context, data *NtpserverResourceModel) ntp.Ntpserver {
	tflog.Debug(ctx, "In ntpserverGetThePayloadFromtheConfig Function")

	// Create API request body from the model
	ntpserver := ntp.Ntpserver{}
	if !data.Autokey.IsNull() {
		ntpserver.Autokey = data.Autokey.ValueBool()
	}
	if !data.Key.IsNull() {
		ntpserver.Key = utils.IntPtr(int(data.Key.ValueInt64()))
	}
	if !data.Maxpoll.IsNull() {
		ntpserver.Maxpoll = utils.IntPtr(int(data.Maxpoll.ValueInt64()))
	}
	if !data.Minpoll.IsNull() {
		ntpserver.Minpoll = utils.IntPtr(int(data.Minpoll.ValueInt64()))
	}
	if !data.Preferredntpserver.IsNull() {
		ntpserver.Preferredntpserver = data.Preferredntpserver.ValueString()
	}
	if !data.Serverip.IsNull() {
		ntpserver.Serverip = data.Serverip.ValueString()
	}
	if !data.Servername.IsNull() {
		ntpserver.Servername = data.Servername.ValueString()
	}

	return ntpserver
}

func ntpserverSetAttrFromGet(ctx context.Context, data *NtpserverResourceModel, getResponseData map[string]interface{}) *NtpserverResourceModel {
	tflog.Debug(ctx, "In ntpserverSetAttrFromGet Function")

	// Convert API response to model
	if val, ok := getResponseData["autokey"]; ok && val != nil {
		data.Autokey = types.BoolValue(val.(bool))
	} else {
		data.Autokey = types.BoolNull()
	}
	if val, ok := getResponseData["key"]; ok && val != nil {
		if intVal, err := utils.ConvertToInt64(val); err == nil {
			data.Key = types.Int64Value(intVal)
		}
	} else {
		data.Key = types.Int64Null()
	}
	if val, ok := getResponseData["maxpoll"]; ok && val != nil {
		if intVal, err := utils.ConvertToInt64(val); err == nil {
			data.Maxpoll = types.Int64Value(intVal)
		}
	} else {
		data.Maxpoll = types.Int64Null()
	}
	if val, ok := getResponseData["minpoll"]; ok && val != nil {
		if intVal, err := utils.ConvertToInt64(val); err == nil {
			data.Minpoll = types.Int64Value(intVal)
		}
	} else {
		data.Minpoll = types.Int64Null()
	}
	if val, ok := getResponseData["preferredntpserver"]; ok && val != nil {
		data.Preferredntpserver = types.StringValue(val.(string))
	} else {
		data.Preferredntpserver = types.StringNull()
	}

	// Handle serverip and servername
	// NetScaler sometimes stores IP addresses in the servername field instead of serverip
	serveripVal, hasServerip := getResponseData["serverip"].(string)
	servernameVal, hasServername := getResponseData["servername"].(string)

	// Set serverip if it exists in the response
	if hasServerip && serveripVal != "" {
		data.Serverip = types.StringValue(serveripVal)
	} else {
		// If serverip doesn't exist but servername does, and the data model expects serverip,
		// use servername value for serverip (NetScaler behavior)
		if !data.Serverip.IsNull() && hasServername && servernameVal != "" {
			data.Serverip = types.StringValue(servernameVal)
		} else {
			data.Serverip = types.StringNull()
		}
	}

	// Set servername if it exists in the response
	if hasServername && servernameVal != "" {
		data.Servername = types.StringValue(servernameVal)
	} else {
		// If servername doesn't exist but serverip does, and the data model expects servername,
		// use serverip value for servername
		if !data.Servername.IsNull() && hasServerip && serveripVal != "" {
			data.Servername = types.StringValue(serveripVal)
		} else {
			data.Servername = types.StringNull()
		}
	}

	// Set ID for the resource based on which identifiers are present in response
	var idParts []string
	if !data.Serverip.IsNull() && !data.Serverip.IsUnknown() {
		idParts = append(idParts, fmt.Sprintf("serverip:%s", data.Serverip.ValueString()))
	}
	if !data.Servername.IsNull() && !data.Servername.IsUnknown() {
		idParts = append(idParts, fmt.Sprintf("servername:%s", data.Servername.ValueString()))
	}
	data.Id = types.StringValue(strings.Join(idParts, ","))

	return data
}
